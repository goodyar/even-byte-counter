# Тестовое задание "Счётчик чётных байтов".

## Общее.
Я отформатировал текст с длиной строки 120 символов. Комментарии в тексте и комментарии в коммитах на русском.
Если это неприемлемо в работе, то я, конечно, могу на английском.

## Архитектура.
Я решил поэкспериментировать и попробовать параллельно читать файл разными способами.

1. Читать `java.io.RandomAccessFile` вручную синхронизировав  метод read. Тогда потоки по очереди
будут сдвигать позицию чтения на величину буфера и по окончанию файла закончат работу. Если время
вычислений с буфером больше время чтения этого буфера, то будет ускорение.
2. Тоже самое, только с `java.nio.channels.FileChannel`. Там не нужна синхронизация. Каналы thread-safe.
3. Разбить файл на виртуальные сегменты по количеству ядер. Запустить поток для каждого такого сегмента,
который будет его читать. У `java.nio.channels.FileChannel` есть такой метод read, который читает с заданной
позиции и не сдвигает курсор.

Таким образом, получается следующая схема. Есть интерфейс File, который описывает читаемый файл.
Класс Counter - счётчик чётных байтов. Класс Worker, который производит чтение из File, вычисление и
запись в Counter. И класс WorkerStarter, который запускает Worker по количеству ядер и передает им на
вход File и Counter.

Реализацию третьего пункта, я оставил в ветке `random-access`. Там добавляются четыре файла, название
которых начинаются с `RandomAccess`.
